# 1684 Разработка визуализатора данных векторного файла G-Code
### Задача проекта
Целевой программный компонент должен обеспечивать визуализацию данных файла траектории (G-Code) в заданной экранной области, допускать масштабирование и сдвиг изображения.
Требуется оптимизировать количество отображаемых данных, не обрабатывая те из них, которые не видны в текущем масштабе, для минимизации задержек при перерисовке изображения.
Компонент предназначен для предпросмотра содержимого файлов заданий и визуализации движения инструмента в составе встраиваемой системы управления для промышленного оборудования.

Целевая IDE: Qt.

Целевая платформа: встраиваемая система на базе ARM/Linux, без графического ускорителя.

### Результаты
Может показаться, что задача вывода изображения является простой. Однако необходимо учитывать несколько важных аспектов. Во-первых, у нас имеются весьма ограниченные ресурсы. Во-вторых, использование самого очевидного способа для векторной визуализации в QT, а именно QGraphicsScene, на больших файлах G-кода (например, объемом 200 тысяч строк), применяемых в крупносерийном производстве, приводит к крайне неудовлетворительным результатам. Объем памяти, занимаемый при этом, может достигать 2 Гб, что является неприемлемым даже для слабых ПК, следовательно и для систем числового программного управления (ЧПУ) на фрезеровочных станках.

Мы также рассмотрели вариант использования растрового изображения для визуализации. Однако в процессе реализации этого подхода мы столкнулись со значительной проблемой. Для обеспечения четкости и различимости мелких деталей необходимо создавать изображение очень большого размера. При малом разрешении эти детали становятся неразличимыми, что делает данный метод неэффективным, что наглядно продемонстрировано на приведенном ниже изображении в сравнении с визуализацией в векторном формате. В связи с этим, после детального анализа и тестирования, мы пришли к выводу, что использование растровой визуализации для наших целей является неприемлемым и нецелесообразным.

![Без имени-1](https://github.com/Lozgacheva/1684_gcode_visualizer/assets/103130716/0c8fc889-1ada-483d-a698-eee46ff57b40)

Первый прототип программы использовал класс QGraphicsScene для визуализации объектов с помощью QPainterPath. В ходе тестирования различных файлов G-Code была выявлена зависимость между количеством объектов на сцене и потребляемыми ресурсами. Например, если на сцене присутствуют сотни тысяч объектов QPainterPath, каждый из которых занимает несколько единиц измерения, объем потребляемой памяти достигает порядка 1 Гб. В то же время, если на сцене находится несколько объектов QPainterPath, охватывающих сотни тысяч единиц измерения, объем потребляемой памяти снижается до примерно 100 Мб.

Именно такой подход реализован в проекте. На сцене хранится один путь, содержащий множество подпутей, которые в свою очередь являются непосредственно объектами. 1 строка G-code (т.е. 1 команда, требующая визуализации) = 1 объект.

Проект состоит из:
- **Парсера (parser/parser.h)**
Парсер открывает G-code файл, считывает построчно, преобразует в объекты класса QPainterPath и добавляет их, как подпути, в один единый путь для всего файла.
- **Парсер для визуализации (parser_process/parser_process.h)** Унаследован от обычного парсера. Команда G0 заменена на G1, чтобы в последующем имитировать процесс фрезерования.
- **Вида (scene/scene.h)**
Сделан собственный класс вида, ограничивающий масштабирования и допускающий масштабирование и сдвиг с помощью сенсорных жестов.
- **main (main.cpp)**


#### Использование подключаемых файлов

Чтобы использовать наш алгоритм визуализации требуется:
- подключить заголовочные файлы parser.h, parser_process.h и scene.h:
```c
#import "parser/parser.h"
#import "scene/scene.h"
```
- создать объект класса GraphicsView, QGraphicsScene и добавить сцену в вид:
```c
GraphicsView view(&window);
QGraphicsScene scene;
view.setScene(&scene);
```
- создать объект класса Parser, распарсить G-Code файл с коэффициентом увеличения coef (рекомендуемое значение coef = 20) и добавить путь из парсера на сцену:
```c
Parser parser;
if(parser.open("path to gcode file")) {
    parser.parse(coef);
}
scene.addPath(parser.get_path(), QPen(Qt::black));
```

#### Чтобы запустить процесс имитации фрезирования требуется:
- подключить заголовочный файл parser_process.h:
```c
#import "parser_process/parser_process.h"
```
- создать объект класса Parser, распарсить тот же G-Code файл, что и был распарсен объектом класса Parser с таким же coef:
```c
Parser_process parser_process;
if(parser_process.open(gcode_file)) {
    parser_process.parse(20);
}
```
- создать "главного актера", который будет показывать имитированное положение станка и добавить его на сцену:
```c
QGraphicsEllipseItem m_actor(0, 0, 10, 10);
m_actor.setBrush(QBrush(QColor(255, 0, 0)));
scene.addItem(&m_actor);
```
- создать таймер, анимацию, сдвиг для "главного актера" (размеры "главного актера" пополам) и запустить анимацию. Ниже выставлены рекомендуемые параметры для всех методов для файла orc.gc:
```c
QTimeLine *timer = new QTimeLine(550000, &window.view);
QGraphicsItemAnimation *animation = new QGraphicsItemAnimation(timer);
timer->setEasingCurve(QEasingCurve::Linear);
animation->setItem(&m_actor);
animation->setTimeLine(timer);
QPointF coef(5, 5);
QPainterPath path_process = parser_process.get_path();
for(qreal j = 0; j <= 1; j += 0.0001) {
    animation->setPosAt(j, path_process.pointAtPercent(j) - coef);
}
timer->start();
```

Следует отметить, что процесс имитации фрезирования требует не мало ресурсов, поэтому не советуется использовать на больших файлах G-Code.
